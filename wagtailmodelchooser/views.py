import re
from django.core import signing
from django.apps import apps
from django.http import Http404
from django.shortcuts import render
from wagtail.admin.modal_workflow import render_modal_workflow
from wagtail.search.index import Indexed
from wagtail.utils.pagination import paginate

from . import registry

instance_str_re = re.compile(r'^([a-z0-9_]+\.[a-zA-Z0-9]+):(.*)$')


def instance_from_str(instance_str):
    """
    Given an instance string in the form "app.Model:pk", returns a tuple of
    ``(model, instance)``. If the pk part is empty, ``instance`` will be
    ``None``. Raises ``ValueError`` on invalid model strings or missing
    instances.
    """
    match = instance_str_re.match(instance_str)
    if not match:
        raise ValueError("Invalid instance string")

    model_string = match.group(1)
    try:
        model = apps.get_model(model_string)
    except (LookupError, ValueError):
        raise ValueError("Invalid instance string")

    pk = match.group(2)
    if pk:
        try:
            return model, model._default_manager.get(pk=pk)
        except model.DoesNotExist:
            raise ValueError("Invalid instance string")

    return model, None


def chooser(request, app_label=None, model_name=None, filter_name=None,
            signed_data=None):
    try:
        if signed_data is not None:
            # Load the data generated by the panel
            # This contains the id of the panel used to retrieve it
            data = signing.loads(signed_data)
            panel = registry.choosers[data['chooser_id']]
            panel = panel.bind_to_model(
                apps.get_model(data['app_label'], data['model_name']))
            instance = panel.get_instance(request, data)
            Form = panel.get_form_class()
            chooser = panel.bind_to_instance(
                instance=instance,
                form=Form(instance=instance),
                request=request)
            model = chooser.target_model
        else:
            model = apps.get_model(app_label, model_name)
            chooser = registry.choosers[model]
    except (LookupError, ValueError, KeyError, signing.BadSignature) as e:
        raise Http404

    qs = chooser.get_queryset(request)

    is_searchable = issubclass(model, Indexed)
    is_searching = is_searchable and request.GET.get('q')

    if is_searching:
        qs = qs.search(request.GET['q'])

    if filter_name is not None:
        try:
            filter_func = registry.filters[model, filter_name]
        except KeyError:
            raise Http404
        qs = filter_func(qs)

    paginator, page = paginate(request, qs, per_page=10)
    ajax = 'ajax' in request.GET

    context = {
        'chooser': chooser,
        'chooser_url': request.path,
        'opts': model._meta,
        'paginator': paginator,
        'page': page,
        'object_list': page.object_list,
        'is_searchable': is_searchable,
        'is_searching': is_searching,
    }

    if ajax:
        return render(request, chooser.results_template, context)

    js_data = {'step': 'initModal'}
    return render_modal_workflow(
        request, chooser.modal_template, None, context, js_data)
